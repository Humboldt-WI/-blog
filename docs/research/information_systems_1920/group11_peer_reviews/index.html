<!DOCTYPE html>
<html lang="en-us">

  <head>
  <meta charset="utf-8">
  <meta name="robots" content="all,follow">
  <meta name="googlebot" content="index,follow,snippet,archive">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Big Peer Review Challenge</title>
  <meta name="author" content="" />

  
  <meta name="keywords" content="devows, hugo, go">	
  

  
  <meta name="description" content="Application of state-of-the-art text classification techniques ELMo and ULMFiT to A Dataset of Peer Reviews (PeerRead)">
  

  <meta name="generator" content="Hugo 0.65.3" />

  <link href='//fonts.googleapis.com/css?family=Roboto:400,100,100italic,300,300italic,500,700,800' rel='stylesheet' type='text/css'>

  
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

  
  <link href="https://humboldt-wi.github.io/blog/css/animate.css" rel="stylesheet">

  
  
    <link href="https://humboldt-wi.github.io/blog/css/style.blue.css" rel="stylesheet" id="theme-stylesheet">
  


  
  <link href="https://humboldt-wi.github.io/blog/css/custom.css" rel="stylesheet">

  
  
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  

  
  <link rel="shortcut icon" href="https://humboldt-wi.github.io/blog/img/favicon.ico" type="image/x-icon" />
  <link rel="apple-touch-icon" href="https://humboldt-wi.github.io/blog/img/apple-touch-icon.png" />
  

  <link href="https://humboldt-wi.github.io/blog/css/owl.carousel.css" rel="stylesheet">
  <link href="https://humboldt-wi.github.io/blog/css/owl.theme.css" rel="stylesheet">

  <link rel="alternate" href="https://humboldt-wi.github.io/index.xml" type="application/rss+xml" title="Institute of Infomation Systems at HU-Berlin">

  
  <meta property="og:title" content="Big Peer Review Challenge" />
  <meta property="og:type" content="website" />
  <meta property="og:url" content="/blog/research/information_systems_1920/group11_peer_reviews//" />
  <meta property="og:image" content="img/logoGross.png" />

</head>


  <body>

    <div id="all">

        <header>

          <div class="navbar-affixed-top" data-spy="affix" data-offset-top="200">

    <div class="navbar navbar-default yamm" role="navigation" id="navbar">

        <div class="container">
            <div class="navbar-header">
                <a class="navbar-brand home" href="https://humboldt-wi.github.io/blog/">
                    <img src="https://humboldt-wi.github.io/blog/img/logo.png" alt="Big Peer Review Challenge logo" class="hidden-xs hidden-sm">
                    <img src="https://humboldt-wi.github.io/blog/img/logo-small.png" alt="Big Peer Review Challenge logo" class="visible-xs visible-sm">
                    <span class="sr-only">Big Peer Review Challenge - go to homepage</span>
                </a>
                <div class="navbar-buttons">
                    <button type="button" class="navbar-toggle btn-template-main" data-toggle="collapse" data-target="#navigation">
                      <span class="sr-only">Toggle Navigation</span>
                        <i class="fa fa-align-justify"></i>
                    </button>
                </div>
            </div>
            

            <div class="navbar-collapse collapse" id="navigation">
                <ul class="nav navbar-nav navbar-right">
                  
                  <li class="dropdown">
                    
                    <a href="/blog/">Home</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/news/">News</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/contributors/">Contributors</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/research/">research</a>
                    
                  </li>
                  
                  <li class="dropdown">
                    
                    <a href="/blog/contact/">Contact</a>
                    
                  </li>
                  
                </ul>
            </div>
            

            <div class="collapse clearfix" id="search">

                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search">
                        <span class="input-group-btn">

                    <button type="submit" class="btn btn-template-main"><i class="fa fa-search"></i></button>

                </span>
                    </div>
                </form>

            </div>
            

        </div>
    </div>
    

</div>




        </header>

        <div id="heading-breadcrumbs">
    <div class="container">
        <div class="row">
            <div class="col-md-12">
                <h1>Big Peer Review Challenge</h1>
            </div>
        </div>
    </div>
</div>


        <div id="content">
            <div class="container">

                <div class="row">

                    

                    <div class="col-md-9" id="blog-post">

                        <p class="text-muted text-uppercase mb-small text-right">By <a href="#">Seminar Information Systems (WS19/20)</a> | February 6, 2020</p>

                        <div id="post-content">
                          <h1 id="big-peer-review-challenge">Big Peer Review Challenge</h1>
<h5 id="asena-ciloglu--melike-merdan">Asena Ciloglu &amp; Melike Merdan</h5>
<h3 id="abstract">Abstract</h3>
<p>This blog post studies the first public dataset of scientific peer reviews available for research purposes <a href="https://github.com/allenai/PeerRead">PeerRead</a> applying state-of-the-art NLP models ELMo and ULMFit to a text classification task [1]. It aims to examine the importance of the peer reviews on paper’s acceptance or rejection decision in well-known conferences of computational linguistics, AI and NLP.</p>
<h3 id="table-of-contents">Table of Contents</h3>
<hr>
<ol>
<li><a href="#introduction">Introduction</a>
<ol>
<li><a href="#peer_review">Peer Review Process</a></li>
<li><a href="#motivation">Motivation</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
</li>
<li><a href="#descriptive">Descriptive Analytics</a>
<ol>
<li><a href="#dataset">A Dataset of Peer Reviews</a>
<ol>
<li><a href="#approach">Approach and Data Extraction</a></li>
</ol>
</li>
<li><a href="#scholarly">Google Scholarly</a></li>
<li><a href="#cleaning">Data Cleaning</a></li>
<li><a href="#insights">Data &amp; Insights</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
</li>
<li><a href="#application">Application</a>
<ol>
<li><a href="#ourapproach">Our Approach</a>
<ol>
<li><a href="#content">Content-based Classification</a></li>
<li><a href="#review">Review-based Classification</a></li>
<li><a href="#auxiliary">Analysis with Auxiliary Data</a></li>
</ol>
</li>
<li><a href="#transfer">Transfer Learning and Recent Applications</a></li>
<li><a href="#elmo">Embedding for Language Models (ELMo)</a>
<ol>
<li><a href="#method">Methodology</a>
<ol>
<li><a href="#deep">Deep Contextualized Word Representations</a></li>
<li><a href="#archi">Model Architecture</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#ulmfit">Universal Language Model Fine Tuning (ULMFit)</a>
<ol>
<li><a href="#method2">Methodology</a>
<ol>
<li><a href="#glm">General Knowledge Domain Training</a></li>
<li><a href="#ttlm">Target Task Language Model Fine Tuning</a></li>
<li><a href="#class">Target Task Classifier</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#svm">Support Vector Machine (SVM)</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
</li>
<li><a href="#res">Empirical Results &amp; Conclusion</a>
<ol>
<li><a href="#cbc">Results</a></li>
<li><a href="#dc">Discussion and Conclusion</a>
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
</li>
<li><a href="#references">Reference List</a></li>
</ol>
<h2 id="1-introduction-a-classanchor-idintroductiona">1. Introduction <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<hr>
<h3 id="11-peer-review-process-a-classanchor-idpeer_reviewa">1.1. Peer Review Process <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<figure><a href="/blog/img/seminar/group11_peer_reviews/peer_reviews.png">
    <img src="/blog/img/seminar/group11_peer_reviews/peer_reviews.png"
         alt="Figure 1: Peer Reviewing Process – Image Source: Flickr AJ Cann, CC BY SA" width="400"/> </a><figcaption>
            <p>Figure 1: Peer Reviewing Process – Image Source: Flickr AJ Cann, CC BY SA</p>
        </figcaption>
</figure>

<p>Peer review is a formal method of scientific evaluation that appeared in the first scientific journals more than 300 years ago. The philosopher Henry Oldenburg (1618-1677) is accepted as the pioneer of the modern peer review process due to his initiation of the process in the journal of The Philosophical Transactions of the Royal Society [17]. The peer review framework is designed to determine the validity and quality of scientific papers for publication. In this way, it is aimed to maintain certain quality standards and credibility for a journal.</p>
<p>When a manuscript is submitted to a scientific journal, it goes through various steps before it is published in the journal. Firstly, the article goes to the editor for a preliminary check if it satisfies the journal&rsquo;s requirements. The manuscripts that pass the editor&rsquo;s evaluation are then sent out for peer review. During the peer review process, the paper is assessed by multiple competent researchers in the field. The reviewers evaluate the scholar work in several aspects such as appropriateness, clarity, substance, impact or originality and provide their evaluation on whether they would recommend the paper to be published or not. Consequently, these peer reviews go through the editor’s assessment and the decision on the manuscript’s acceptance or rejection is made. In some cases, the manuscript could be revised and resubmitted again for a final decision. A rejection does not necessarily mean the poor quality of the paper but it rather indicates the paper is not on the line with the journal-specific requirements.</p>
<p>Peer reviewing process is generally not paid since they are considered a valuable contribution to science and research and hence the process voluntary and self-regulatory. In this regard, their robustness and efficacy have been discussed by the experts and there are several approaches suggested to these processes. The traditional way is the single-blind reviewing process where the names of the reviewers are not shared with the author, and therefore any possible negative interaction between the author and the reviewer is avoided. However, the reviewers are able to observe the author&rsquo;s name and this could potentially lead to a bias towards the author. To tackle the problem, double-blind reviews are introduced where neither the reviewer nor the author observes each other&rsquo;s name. The anonymity is expected to prevent biases based on the name, gender, or reputation and provide a more reliable environment for scientific work. Despite this, there exists also other methods such as a third-blind review or open review yet the aforementioned two are the most common current approaches.
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="12-motivation-a-classanchor-idmotivationa">1.2. Motivation <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p>Though the double-blind review process is introduced to limit possible biases, it has been discussed whether reviews could still identify the authors through their writing style or methodology and whether the process might be totally anonymized. This ongoing criticism about the integrity, consistency and general quality of peer review motivated us to elaborate more on the data available and determine if the data gives us any hint about the questions addressed to peer reviews since peer reviews are still believed to be the best form of scientific evaluation and used by the majority of scientists including prestigious venues.</p>
<h5 id="nips-experiment">NIPS Experiment</h5>
<p>In 2014 the organization committee of the NIPS Conference, one of the largest conferences in AI, conducted a thought-provoking experiment where they tasked two committees to review the same 10% of the conference submissions to assess the consistency of the peer review process [10]. The committees were assigned a certain acceptance rate of 22.5% but not told that the submissions are concurrently revised by another committee. In the end, the organizers observed that the committees disagreed on more than a quarter of the papers. In other words, approximately 57% of the total list of accepted papers by both committees are accepted by one of the committees and rejected by the other one given a set acceptance rate. This result addressed once again the robustness of the peer review process and questioned the consistency of the reviewers.
In our study, we examine numerous articles submitted to reputable scientific conferences in the areas of computational linguistics, natural language processing and deep learning including the NIPS Conference, and their respective peer reviews. We aim to evaluate the consistency and effectiveness of the reviews on acceptance decisions of the submitted manuscripts by applying multiple text classification tasks with deep learning.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="2-descriptive-analytics-a-classanchor-iddescriptivea">2. Descriptive Analytics <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="21-a-dataset-of-peer-reviews-a-classanchor-iddataseta">2.1. A Dataset of Peer Reviews <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Our reference dataset is from the paper called A Dataset of Peer Reviews (PeerRead)  [1]. The main purpose of this paper was to illustrate the extracted output of the PeerRead dataset and take us through the validation process of data extraction. They gathered 14.7K paper drafts and the corresponding accept/reject decisions in top-tier venues including Association of Computational Linguistics (ACL), Conference on Computational Natural Language Learning (CoNLL), International Conference on Learning Representations (ICLR), Conference on Neural Information Processing Systems (NIPS); 10.7K textual peer reviews written by experts for a subset of the papers. The four conferences usually serve for similar topics in academia such as machine learning, deep learning, computational linguistics, and natural language learning.  In addition to that, they made use of the information on arXiv.com where they could only benefit from the paper itself. For consistency, only the first arXiv version of each paper (accepted or rejected) in the dataset is included and considered accepted if it is accepted in any of the valid scientific venues. The dataset source can be found <a href="https://github.com/allenai/PeerRead">here.</a></p>
<p>Their analysis is twofold: firstly they analyzed acceptance classification based on paper drafts; secondly, they predicted the aspect scores based on the reviews. In the first analysis, they used models such as Support Vector Machine, Logistic Regression, and Decision Trees while they did not prefer to use a machine learning algorithm as they evaluated them too hard to interpret in this task [1].  After each review had been held, the reviewer was asked to give aspect scores along with the review. The aspect scores are impact, substance, appropriateness, comparison, soundness, originality, and clarity. In order to predict aspect scores, they used machine learning algorithms such as CNN, RNN and Deep Averaging Networks (DAN).
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="211-approach-and-data-extraction-a-classanchor-idapproacha">2.1.1. Approach and Data Extraction <!-- raw HTML omitted --><!-- raw HTML omitted --></h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>Through our analysis, we followed the PeerRead paper while constructing our dataset. Data collection varies across sections because each might have different license agreements. ACL and ConLL, ICLR and arXiv datasets were publicly available in JSON formats. For ConLL, we manually added the acceptance/rejection information. On the other hand, NIPS data had to be crawled due to license issues, however, it is also publicly available to do so.</p>
<p><img src="/blog/img/seminar/group11_peer_reviews/dataset.jpeg" alt="Dataset">
Figure 2: Our Dataset</p>
<p>It is important to note that, for ACL and ConLL datasets, we are only able to reach the opt-in reviews, where both the writer and the reviewer agree to share the reviews and the paper draft. This might cause a positive bias where papers with &lsquo;good&rsquo; reviews might tend to reveal themselves than the rejected papers. Additionally, for NIPS, we are only able to reach the accepted papers since they only publicize the accepted papers&rsquo; information on their website.
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="22-google-scholarly-a-classanchor-idscholarlya">2.2. Google Scholarly <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p>Google Scholar is a web search engine that is freely available where anyone can reach the full text or metadata of scholarly literature across an array of publishing formats and disciplines [2]. To crawl information from Google Scholar, one can utilize a package available called &lsquo;scholarly&rsquo;. &lsquo;Scholarly&rsquo; is a module that allows you to retrieve author and publication information from Google Scholar in a friendly, Pythonic way [3].
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/bc93e54d2a29722a9a749564c0c906e6.js"></script>
</p>
<p>In our dataset, we first eliminated the papers without the authors publicly available, then extracted each author&rsquo;s following information. As Google Scholar prints output similar to a dictionary, we first printed this output on a JSON file. Later on our analysis, we used the author&rsquo;s affiliation with an institution, to see its predictive power on our task.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="23-data-cleaning-a-classanchor-idcleaninga">2.3. Data Cleaning <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
When performing Natural Language Processing tasks, data cleaning has a crucial role [4]. After cleaning the text from potential noise, one can conduct a powerful analysis.</p>
<p>Our cleaning consists of four main tasks: clearing from any punctuation, lower case all text, remove stopwords and stemming. Performing a ready-set stopword might cause loss of information, for example in our text analysis, we wouldn&rsquo;t like to lose the word &lsquo;not&rsquo; when working on a text classification task. Therefore, we first performed regular expressions cleaning, then removed the stop words that we agreed on.</p>
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/d016d399a0a99ed41590fa5f9a7df956.js"></script>

<p>Cleaning words with stemming is highly debatable. After performing stemming, we reach the roots of a given word. This enables us to end up with core words, with less unnecessary variations at the cost of losing some valuable information. Since the papers and reviews are already too long to work with, we decided to perform stemming as a part of our cleaning process.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="24-data--insights-a-classanchor-idinsightsa">2.4. Data &amp; Insights <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
Checking our data for most common words, we do not observe much difference when checking for abstract or for reviews. From the below word cloud, one can easily see that &lsquo;learn&rsquo;, &lsquo;model&rsquo; and &lsquo;use&rsquo; have been the most common words for reviews. Furthermore, we performed a TF-IDF analysis to examine the weights of each word on acceptance or rejection. However, we did not see a notable difference in common words between accepted and rejected papers.
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/be636ca217748918ae4b0de197822c79.js"></script>
</p>
<p>Fortunately, NIPS allowed us to reach 30 years of old author information for published papers. The below graph shows that most of the papers published on NIPS conference were written by more than one author, so through collaboration.</p>
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/b84bcceb8017fe6e1992e1179565a036.js"></script>

<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h2 id="3-application-a-classanchor-idapplicationa">3. Application <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<hr>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="31-our-approach-a-classanchor-idourapproacha">3.1. Our Approach <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<h4 id="311-content-based-classification-a-classanchor-idcontenta">3.1.1. Content-based Classification <!-- raw HTML omitted --><!-- raw HTML omitted --></h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
Our first approach is a text classification analysis in deep learning based on the content of submitted papers. We aim to examine how much impact the content of a paper has on paper&rsquo;s classification of acceptance or rejection. Our curiosity is driven by the question if there are some dominant topics or keywords with a higher probability to get accepted for publication. Furthermore, we would like to see how effective paper&rsquo;s content in general on the classification. On that account, we would like to choose an approach where we provide a substantial and informative part of a paper while we keep being frugal to avoid computational heaviness. Thus, we used the abstract part of each paper since abstract is a summary of the study ascertaining the paper&rsquo;s purpose, subject matter and sometimes briefly its methodology as well.
To obtain more reliable results, we used our entire dataset available for this analysis since we don&rsquo;t have any paper without an abstract in our dataset. To be more precise, the dataset consists of papers submitted papers of ACL 2017, CoNLL 2016, ICLR 2017, NIPS 2014-2016, and arXiv 2007-2017 submissions. For the analysis, we used transfer learning methods ELMo and ULMFit and compared the results with a benchmark of Lasso Regression.
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="312-review-based-classification-a-classanchor-idreviewa">3.1.2. Review-based Classification <!-- raw HTML omitted --><!-- raw HTML omitted --></h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
Our second approach is galvanized by our main motivation for peer reviews. By analyzing the body of peer reviews we would like to inspect their role on the final classification decision. A text classification task with deep learning methods, we believe, demonstrates how powerful and capable the reviews for acceptance or rejection. We expect that the reviews must be noticeably successful at predicting paper&rsquo;s classification as long as they are relevant and consistent with the paper itself.
In this part of our analysis, we could use a small portion of our dataset since we were only given reviews from the four conferences but the arXiv submissions. To keep our dataset for the analysis balanced to some extent, we used the reviews from  ACL 2017, ConLL 2016, ICLR 2017 that represent the whole dataset we have for these conferences but only the year of 2016 for the NIPS conference. The underlying reason is that the NIPS conference solely makes the accepted articles publicly available. For this task, we used again transfer learning methods ELMo and ULMFit and Lasso Regression for benchmark comparison.</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="313-analysis-with-auxiliary-data-a-classanchor-idauxiliarya">3.1.3. Analysis with Auxiliary Data <!-- raw HTML omitted --><!-- raw HTML omitted --></h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
Our last approach is based on the auxiliary data about authors&rsquo; institutions we scraped from Google Scholar archive. We intend to observe whether there is a positive bias towards authors from recognized institutions or negative bias towards authors from various other less known institutions. Although our dataset with an exception of ICLR 2017 consists of double-blind reviews as aforementioned above, it is not entirely impossible to identify authors by their writing style or methodology and create a bias accordingly. The dataset we obtained from ACL and ConLL conferences are the submissions that were opted-in to be published for academic research, and thus they did not contain any information about the authors. Therefore, we removed this part from our dataset and solely used the authors from ICLR 2017, NIPS 2014-2016, and arXiv 2007-2017 submissions. Even though we used the whole list of author names from these submissions, we ended up using approximately 50% of the dataset because some authors were not listed on Google Scholar and some of them have their names written differently and they did not match with the submissions in the end.
In this analysis, we used authors’ affiliation as text input to the model since one paper is commonly written by more than one author instead of factoring various affiliation categories from several authors writing one paper. Hence, we would like to use the SVM model that accounts for the frequencies of the terms via the TF-IDF method. We performed the SVM model to predict the article classification based on the only review, only institution, and both review and institution to observe the author&rsquo;s affiliation&rsquo;s impact on the acceptance or rejection decision.
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="32-transfer-learning-and-recent-applications-a-classanchor-idtransfera">3.2. Transfer Learning and Recent Applications <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
We sometimes have a task to solve in one domain of interest while we only have big enough data in another domain of interest where the latter data is much bigger and available to solve a classification task. Under these circumstances, transfer learning helps us to use the sufficiently big data to train our language model and benefit the information to solve the task of interest [6].</p>
<p>Deep learning enables us to learn non-linear relationships directly from data using neural network architectures. Deep learning has achieved impressive success in the field of computer vision by hitting the mark in image classification [7]. Inspired by ImageNet models on computer vision, transfer learning in Natural Language Processing has brought the field a long way [5]. In a text classification model, it firstly builds a language model to gain knowledge of the language distribution and then continues training the model on the specific classification task. When the language model is trained, it creates word vectors that hold the information about the input that can be applied to different tasks later. As word vectors as NLP&rsquo;s core representation have gained importance during the past few years, a new line of state of the art models has emerged in this fields such as ELMo, ULMFit and Open AI Transformer [5].
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="33-embedding-for-language-models-elmo-a-classanchor-idelmoa">3.3. Embedding for Language Models (ELMo) <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
The idea of applying transfer learning to NLP models influenced many data scientists in the year of 2018. From the very beginning until the end of the year, new NLP models using transfer learning appeared following one another. Embeddings from Language Models (ELMo) model emerged at the beginning of this flow and was introduced in February 2018 by the researchers of the Allen Institute for Artificial Intelligence (AllenNLP).
Its approach is basically training a language model on a large corpus, extracting features and using these pre-trained representations in a randomly initialized downstream models. It has 4 pre-trained models with a different number of parameters, highway layers, LSTM size, and output size: small, medium, original and original (5.5B). All models except for the 5.5B model were trained on the <a href="http://www.statmt.org/lm-benchmark/">1 Billion Word Benchmark</a>, approximately 800M tokens of news crawl data from WMT 2011. The ELMo 5.5B model was trained on a dataset of 5.5B tokens consisting of Wikipedia (1.9B) and all of the monolingual news crawl data from WMT 2008-2012 (3.6B) [16].</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="331-methodology-a-classanchor-idmethoda">3.3.1 Methodology <!-- raw HTML omitted --><!-- raw HTML omitted --></h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
Unlike the commonly used word embeddings GLoVe and word2vec, ELMo word representations are deep contextualized and functions of the entire input sentence allowing to model the characteristics of word use (e.g., syntax and semantics) and how these uses change across different linguistic contexts (i.e., model polysemy). The word vectors are computed on top of a two-layer bidirectional language model (biLM) with character convolutions as a linear function of the internal network states that is pre-trained on a large text corpus. The model setup enables semi-supervised learning that can be incorporated into a wide range of NLP applications such as sentiment analysis and textual entailment [16].
<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="3311-deep-contextualized-word-representations-a-classanchor-iddeepa">3.3.1.1. Deep Contextualized Word Representations <!-- raw HTML omitted --><!-- raw HTML omitted --></h5>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
ELMo has its power from its unique word representations that are character-based, contextual, and deep. These deep contextualized word representations account for the entire context in which it is used compared to the existing word embeddings GLoVe and word2vec that use set word representations regardless of the context. In other words, the word “stick” would have different representations when used in the following two sentences: “Let’s stick to the original plan!” and “I cannot find my USB stick anywhere!”. Even though the word “stick” is exactly the same, its contextual meaning varies across the sentences and thus its ELMo representations change accordingly as well. If we use the traditional word embeddings like GLoVe or word2vec, the word “stick” would have the same vector representation in both and all the other possible use cases.</p>
<p>Having a “deep” characteristics ELMo representations are a function of all layers of the deep pre-trained biLM. They are a linear combination of the vectors stacked above each input word for each end task. This method allows higher LSTM levels to capture context-dependent features of word meaning and lower LSTM levels to seize the syntax, and overall leading to better model performance.
The purely character-based representations of ELMo allow the network to capture the inner-structure of the word and use morphological information for the words which were not observed during training. Furthermore, the neural network is capable of distinguishing between the words coming from the same root such as beauty and beautiful, while it discerns these words are related.</p>
<p>Let&rsquo;s set up our system for ELMo!</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># We use TensorFlow Hub with Keras for ELMo representations</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">tensorflow_hub</span> <span style="color:#a2f;font-weight:bold">as</span> <span style="color:#00f;font-weight:bold">hub</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">tensorflow</span> <span style="color:#a2f;font-weight:bold">as</span> <span style="color:#00f;font-weight:bold">tf</span></code></pre></div>
<p>An example of how ELMo embeddings looks like:</p>
<script type="application/javascript" src="https://gist.github.com/merdanme/da242fafd29240d0b625c68764b86a0a.js"></script>

<ul>
<li>The first dimension represents the number of training samples.</li>
<li>The second dimension represents the maximum length of the longest string in the input list of strings. As we have only 1 string in our example, the longest input length is equal to 10.</li>
<li>The third dimension is equal to the length of the ELMo vector. Thus, every word in the input sentence has an ELMo vector of size 1024.</li>
</ul>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="3312-model-architecture-a-classanchor-idarchia">3.3.1.2. Model Architecture <!-- raw HTML omitted --><!-- raw HTML omitted --></h5>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p><img src="/blog/img/seminar/group11_peer_reviews/elmo_gif.gif" alt="ELMo Model">
Figure 3: The Architecture of ELMo</p>
<p>In ELMo model architecture, ELMo word vectors are computed on top of a two-layer biLM and they derive from the combination of intermediate word vectors as illustrated in the figure.</p>
<ul>
<li>Step 1: The model consists of two bidirectional LSTM layers that allow the model to contain information not only from the words on the left-hand side but also from the ones on the right-hand side.</li>
<li>Step 2: The raw word vectors are the input of the first biLM layer through the backward and forward pass.</li>
<li>Step 3: Word vectors exiting the first LSTM layers constitute the first intermediate word vectors.</li>
<li>Step 4: They pass through the second biLM creating the second intermediate word vectors.</li>
<li>Step 5: The final ELMo representation is the weighted sum of the raw word vectors and the two intermediate word vectors.</li>
</ul>
<p>Let’s have a look at how we implement this process in Python!</p>
<p>We firstly call ELMo embeddings through TensorFlow Hub and define them.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">embed <span style="color:#666">=</span> hub<span style="color:#666">.</span>Module(<span style="color:#b44">&#34;https://tfhub.dev/google/elmo/2&#34;</span>)
<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">ELMoEmbedding</span>(x):
    <span style="color:#a2f;font-weight:bold">return</span> embed(tf<span style="color:#666">.</span>reshape(tf<span style="color:#666">.</span>cast(x, tf<span style="color:#666">.</span>string), [<span style="color:#666">-</span><span style="color:#666">1</span>]), signature<span style="color:#666">=</span><span style="color:#b44">&#34;default&#34;</span>, as_dict<span style="color:#666">=</span>True)[<span style="color:#b44">&#39;default&#39;</span>]</code></pre></div>
<p>As a second step, we define recall, precision and F1 score to add as our metrics. Due to our imbalanced dataset, we prefer to use F-Score as our model comparison metrics rather than accuracy since accuracy might be misleading when used in imbalanced datasets.</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">recall_m</span>(y_true, y_pred):
        true_positives <span style="color:#666">=</span> K<span style="color:#666">.</span>sum(K<span style="color:#666">.</span>round(K<span style="color:#666">.</span>clip(y_true <span style="color:#666">*</span> y_pred, <span style="color:#666">0</span>, <span style="color:#666">1</span>)))
        possible_positives <span style="color:#666">=</span> K<span style="color:#666">.</span>sum(K<span style="color:#666">.</span>round(K<span style="color:#666">.</span>clip(y_true, <span style="color:#666">0</span>, <span style="color:#666">1</span>)))
        recall <span style="color:#666">=</span> true_positives <span style="color:#666">/</span> (possible_positives <span style="color:#666">+</span> K<span style="color:#666">.</span>epsilon())
        <span style="color:#a2f;font-weight:bold">return</span> recall

<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">precision_m</span>(y_true, y_pred):
        true_positives <span style="color:#666">=</span> K<span style="color:#666">.</span>sum(K<span style="color:#666">.</span>round(K<span style="color:#666">.</span>clip(y_true <span style="color:#666">*</span> y_pred, <span style="color:#666">0</span>, <span style="color:#666">1</span>)))
        predicted_positives <span style="color:#666">=</span> K<span style="color:#666">.</span>sum(K<span style="color:#666">.</span>round(K<span style="color:#666">.</span>clip(y_pred, <span style="color:#666">0</span>, <span style="color:#666">1</span>)))
        precision <span style="color:#666">=</span> true_positives <span style="color:#666">/</span> (predicted_positives <span style="color:#666">+</span> K<span style="color:#666">.</span>epsilon())
        <span style="color:#a2f;font-weight:bold">return</span> precision

<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">f1_m</span>(y_true, y_pred):
    precision <span style="color:#666">=</span> precision_m(y_true, y_pred)
    recall <span style="color:#666">=</span> recall_m(y_true, y_pred)
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">2</span><span style="color:#666">*</span>((precision<span style="color:#666">*</span>recall)<span style="color:#666">/</span>(precision<span style="color:#666">+</span>recall<span style="color:#666">+</span>K<span style="color:#666">.</span>epsilon()))</code></pre></div>
<p>Then, we build our NLP model using ELMo vectors for our text classification task where we try to predict the manuscript’s classification as accepted or rejected based on its reviews.</p>
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/3373f2e49021a477388bd648dc857dbb.js"></script>

<p>The model takes untokenized sentences as input and tokenizes each string by splitting on spaces. Moreover, the input is a string tensor with a shape of 1, which indicates the batch size. [18]</p>
<p>Finally, we train our model on the dataset in 10 epochs with a batch size of 16 and validate on our test dataset.</p>
<script type="application/javascript" src="https://gist.github.com/merdanme/c6e4eba48602116983a46aebefc450a0.js"></script>

<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="34-universal-language-model-fine-tuning-ulmfit-a-classanchor-idulmfita">3.4. Universal Language Model Fine Tuning (ULMFit) <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
ULMFit proposes an effective transfer learning method which can be applied to any type of NLP task, that puts forward key techniques that are crucial for fine-tuning [8]. Before the introduction of ULMFit, existing transfer learning methods for NLP required task-specific modifications or training from scratch. As also mentioned in section 3.2, in real word NLP tasks, it is often observed that our existing domain and the domain of interest might differ greatly. To solve this problem, Ruder and Howard combined the fine-tuning technique with traditional transfer learning methods to improve the transfer learning process. With ULMFit architecture, we can now achieve higher accuracy and better performances with fewer data and time as the model does not need to learn everything from scratch [7].
ULMFit introduces new approaches to better tackle solutions such as finding documents relevant to the legal case, identifying spam, bots, and offensive comments; classifying positive and negative reviews of products and grouping articles by political orientation [7].</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h4 id="341-methodology-a-classanchor-idmethod2a">3.4.1 Methodology <!-- raw HTML omitted --><!-- raw HTML omitted --></h4>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
The model structure consists of the AWD-LSTM language model, an LSTM (without attention, short-cut connections, or other additions) along numerous tuned dropout hyperparameters[8]. As its name suggests, ULMFit is designed to be universally applicable approach in that  it has the following features: it works across tasks varying in document size, number, and label type; uses a single architecture and training process;  requires no custom feature engineering or preprocessing and does not require additional in-domain documents or labels [7]
The necessary packages to construct an ULMFit model can be downloaded as shown below. Besides, if one wants to study further the building blocks of the ULMFit model can benefit from Jeremy Howard&rsquo;s lectures from <a href="https://www.youtube.com/watch?v=XfoYk_Z5AkI&amp;list=PLfYUBJiXbdtSIJb-Qd3pw0cqCbkGeS0xn">here.</a>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">#pip install torch_nightly -f https://download.pytorch.org/whl/nightly/cu92/torch_nightly.html</span>
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">fastai</span>
<span style="color:#a2f;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">fastai</span> <span style="color:#a2f;font-weight:bold">import</span> <span style="color:#666">*</span>
<span style="color:#a2f;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">fastai.text</span> <span style="color:#a2f;font-weight:bold">import</span> <span style="color:#666">*</span> 
<span style="color:#a2f;font-weight:bold">from</span> <span style="color:#00f;font-weight:bold">functools</span> <span style="color:#a2f;font-weight:bold">import</span> partial
<span style="color:#a2f;font-weight:bold">import</span> <span style="color:#00f;font-weight:bold">io</span></code></pre></div></p>
<p><img src="/blog/img/seminar/group11_peer_reviews/ulmfit.jpeg" alt="ULMFit">
Figure 4: The Architecture of ULMFit [8]</p>
<p>The figure above shows the steps of the ULMFit model: a) General-domain LM pretraining; b) target task LM fine-tuning; and finally c) target task classifier fine-tuning [8]. In the following sections, we will briefly explain each step and its key features.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="3411-general-knowledge-domain-training-a-classanchor-idglma">3.4.1.1. General Knowledge Domain Training <!-- raw HTML omitted --><!-- raw HTML omitted --></h5>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>To start with, one needs to create a language model to gather information for transfer learning. A language model is an NLP model that is trained to learn predicting the next word in a sentence. To do so, it is important to acquire a reasonably general and large language corpus to train a universal language model that is suitable for fine-tuning [7].
ULMFit model uses Stephen Merity&rsquo;s Wikitext 103 dataset which is created from a pre-processed large subset of English Wikipedia consisting of  28,595 preprocessed Wikipedia articles and 103 million words [7] [8]. The original dataset is available <a href="https://blog.einstein.ai/the-wikitext-long-term-dependency-language-modeling-dataset/">here.</a>
Training the language model has been done by running the text corpus through a bidirectional language model with an embedding size of 400,  3 layers and 1150 hidden activations per layer [8]. In our analysis, we download the pre-trained model through the &lsquo;fastai&rsquo; package and there is no additional required code to preprocess the text as it is a built-in in the package&rsquo;s function. The code for pretraining the language model is available online, however it takes approximately around 2 to 3 days by a computer with a decent GPU. Since we aim to benefit from transfer learning, we will not be training a language model.<!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="3412-target-task-language-model-fine-tuning-a-classanchor-idttlma">3.4.1.2. Target Task Language Model Fine Tuning <!-- raw HTML omitted --><!-- raw HTML omitted --></h5>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<p>After acquiring the language model, we will now elaborate on how to transfer learning works on our actual data. Using only a single layer of weights (embeddings) for transfer learning has been convenient for some years thanks to their ease of use, however, these weights only penetrate through the surface of the neural network. However, in practice, neural networks usually contain more than one layer, so the information has to be transferred to other layers otherwise information from transfer learning might be lost in the process.</p>
<p>Ruder and Howard make use of Average SGD Weight Dropped LSTM, AWD-LSTM in short, which is introduced by Stephen Merity for language modeling to prevent information loss during transfer learning. The weight-dropped LSTM benefits from DropConnect instead of a de facto dropout, which drove a dramatic improvement over past methods for language modeling [9].</p>
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/8d8fbb9a1b201e4e2ddc00f9e734c85e.js"></script>

<p>Dropout sets randomly selected subset of activations to zero within each layer while DropConnect sets a randomly selected subset of weights within the network to zero [11]. Dropout, so far, was successful, however, it is found to be somewhat ineffective for transfer learning as it disrupts the Recurrent Neural Network&rsquo;s ability to retain long-term dependencies.
Besides AWD-LSTM, fine-tuning is another key characteristic of the ULMFit model. Since our data has a different distribution than Wiki Text103, we have to fine-tune our language model along with the PeerRead data. However, if the fine-tuning has been done aggressively or ineffectively, it is usually observed that the model suffers from catastrophic forgetting. Because of that, they propose three new methods that are crucial for retaining previous knowledge and prevent catastrophic forgetting [8]: 1) discriminative fine-tuning: 2) slanted triangular learning rates; 3) gradual unfreezing. These three processes enable the model to train a robust language model even for small datasets.
Gradual Unfreezing: This method suggests that instead of fine-tuning all layers at once, we gradually unfreeze the model starting from the last layer where it contains the least general information to the first layer where the most information is hidden [13]. In application, we first unfreeze the last layer and train it for one epoch, then we unfreeze the next layer and train for another epoch and continue these steps until we unfreeze all the layers in the model. This approach is implemented in our code with &lsquo;freeze_to&rsquo; function as in freeze_to(-1) would indicate that we are freezing all LSTM layers except the last layer.</p>
<p>Discriminative Fine-Tuning: Also indicated in gradual unfreezing, each layer in our model has to be trained separately to obtain the highest possible information as each layer contains different types of information. Hence, so it is worth to fine-tune them to different extents. In discriminative fine-tuning, instead of using the same learning rate for all layers, we assign different learning rates to each layer [8][13].  During the empirical studies in this field, it was discovered that first fine-tuning the last layer, and then unfreezing all the layers step by step until all the layers are unfrozen works well with lowering the learning rate by a factor of 2.6 on each step [8].</p>
<p>Slanted triangular learning rates: When we are assigning different learning rates for each layer, we need to find the optimal learning rate that would fit the training efficiently. Rather than manually setting the learning rate for each layer, Howard and Ruder deploy the slanted triangular learning rate method to the model to converge to a suitable region of the parameter space at the beginning of training and then refine its parameters [8]. The idea of slanted triangular learning rate is that it first linearly increases the learning rate and then linearly decays it meanwhile trying to find optimal learning late [12]. In ULMFit implementation, &lsquo;fit_one_cycle&rsquo; function and &lsquo;lr_find&rsquo; help us employ this method.</p>
<p><img src="/blog/img/seminar/group11_peer_reviews/slanted.jpeg" alt="Slanted Triangular Learning Rate">
Figure 5: Slanted Triangular Learning Rate Schedule</p>
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/ca527102f38e70243ded7428a7213bea.js"></script>

<p>Here, we can observe the possible good learning rates for our training, however, it is suggested to use fit_one_cycle with a learning rate slightly bigger than the plot shows as we will perform slanted triangular learning rate schedule in fit_one_cycle function. In our case, the value of 1e-2  seems good to start with.
When using the 1-cycle learning rate policy, we determine 2 values for momentum, first one for higher bound and the other one for the lower bound. The implementation of the momentum is two ways: first, we decrease the momentum from higher to lower bound and then we do the opposite. Based on Ruder and Howard&rsquo;s paper, this cyclic momentum gives a similar result to set the parameter manually, however it is crucially useful in terms of time-saving [8][12].
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/50fc65621a3c0408613e39f8279d9854.js"></script>
</p>
<p>The accuracy implies how good the language model is at predicting the next word in the sentence. As a reminder, we are still training our model to learn how to predict the next word in a sentence. We finally save our fine-tuned language model trained with our target and domain data.</p>
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/5d658ea8c93ac9fe5412a96f812e6950.js"></script>

<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h5 id="3413-target-task-classifier-a-classanchor-idclassa">3.4.1.3. Target Task Classifier <!-- raw HTML omitted --><!-- raw HTML omitted --></h5>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
Fine-tuning the target task classifier is the most critical part because now we will finally be able to use all gathered information the deploy on our task. Similar to how to fine-tune the language model, we also need to fine-tune the target task classifier as overly aggressive fine-tuning will cause catastrophic forgetting and being too cautious would result in a slow convergence and thus overfitting [8]. Therefore, we apply three key approaches in fine-tuning as well on target task classifier training: gradual unfreezing, discriminative fine-tuning and slanted triangular learning rates.</p>
<p>First, we need to upload the target data once again, this time for creating the text classifier. With &lsquo;text_classifier_learner&rsquo; function, we can specify our actual task. Then we will start fine-tuning according to our target task.
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/cda9c0f0d93b7064ba0f10fb5be25506.js"></script>
</p>
<p>When using fit_one_cycle, one can benefit from &lsquo;slice&rsquo; function. The first element of slice indicates the start and the last shows the end, and the remaining are evenly geometrically space. As you go from layer to layer, we decrease the learning rate. The lowest levels are given smaller learning rates so as not to disturb the weights much. In order to make predictions, we add our test data to the model and use &lsquo;get_preds&rsquo; function from the package.
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/1ac0ea6985ad4a97459db9e4b828a62b.js"></script>
</p>
<p><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<h3 id="35-support-vector-machine-svm-a-classanchor-idsvma">3.5. Support Vector Machine (SVM) <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p><!-- raw HTML omitted --><!-- raw HTML omitted -->
The support vector machine is a supervised machine learning algorithm that relies on the idea that input vectors are non-linearly mapped in very high-dimension feature space [14]. SVM algorithm fits these input vectors according to their labels, and through the characteristics of the data points, it determines where the new observation belongs in the model labeling. Let&rsquo;s imagine a big set of two-dimensional training examples, similar to a scatter plot, each point belongs to one group or the other of two categories. SVM algorithm runs a non-probabilistic binary linear classifier that assigns new data points to either of the categories. Since we are running a binary classification, we can use the SVM algorithm directly. However, it is also possible to make an analysis with multi-class labeled data or with unlabeled data, unsupervised learning, but the algorithm has to be adjusted [15].
<script type="application/javascript" src="https://gist.github.com/asenaciloglu/428d61020e4d0b2b788cd53bd339c52f.js"></script>
</p>
<p>The recipe for applying Support Vector Machine for NLP tasks is quite easy to implement.</p>
<ol>
<li>First, we start by downloading the necessary packages. <!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li>We split our data into test and train. Our variable of interest is the author&rsquo;s affiliation with an institution. <!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li>Later, we encode the labels of the target variable, in our case its acceptance of the paper. <!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li>We vectorize the words by using a vectorizer function. In our model, we decided to apply TF-IDF because it is good to find how important a word in a document is in comparison to the corpus. We only fit on our train data, since it is usually bigger and we need to create a matrix as broad as possible. Afterward, we transform both train and test to create a sparse matrix that both transformed matrices are as wide as the train sparse matrix.<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
<li>Finally, we run the algorithm to make the classification and check the good of fitness.<!-- raw HTML omitted --><!-- raw HTML omitted -->
<!-- raw HTML omitted --><!-- raw HTML omitted --></li>
</ol>
<h2 id="4-empirical-results--conclusion-a-classanchor-idresa">4. Empirical Results &amp; Conclusion <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<hr>
<h3 id="41-results-a-classanchor-idcbca">4.1. Results <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p>We used ELMo and ULMFit for our review-based text and content-based (abstract) classification analyses to predict whether a paper is accepted or rejected, and compared the results with a benchmark of Lasso Regression. As comparison metrics, we checked both for accuracy and F-score, where the latter is likely to present more reliable results due to our imbalanced dataset.</p>
<p>In all three models we worked with, we obtained better results - higher accuracy and F-score - in the review-based analysis. This is a relieving finding for us reflecting that reviews are indeed not meaningless or inconsistent with each other to a large extent. They still do have a high predictive power - and definitely higher compared to abstracts that contain contextual informative words in short paragraphs. The ELMo model has the highest accuracy among three with 78.55%, whereas Lasso Regression has a slightly higher F-score than ELMo with 87.89% compared to 87.68%. ULMFit has, on the other hand, the lowest accuracy and F-score. These scores were reached after tuning the model for our dataset. Yet in ELMo case, for instance, we only used 10 epochs due to computational heaviness. With a larger number of epochs and a more powerful computational system, the scores could be different.</p>
<p>In the content-based analysis, we have the same pattern in which the highest accuracy belongs to ELMo with 77.71% and the highest F-score belongs to Lasso Regression with 58%. We can easily observe the huge drop in the F-score demonstrating the low predictive capability of abstracts. ULMFit, nonetheless, obtained significantly lower scores both for accuracy (70.5%) and F-score (35.5%).</p>
<p>In the dataset of review-based analysis, we face an imbalance of 74% acceptance and 26% rejection whereas for the dataset abstract-based analysis the proportions are vice versa with 33% acceptance and 67% rejection. Although the datasets are not entirely balanced, one can still argue that an imbalance of 1:3 or 1:2 may be acceptable. Nevertheless, we examined the case for our dataset and ran our entire analysis again with balanced undersampled data. However, the results we obtained were significantly lower. Besides, in the text classification dataset, we did not prefer oversampling by creating new texts for reviews and abstracts due to the problem of reliability. Therefore, we only considered and compared the results with the entire dataset without undersampling.</p>
<p>Lastly, we used SVM for our analysis with auxiliary data in which we elaborated on the author’s institution. We predicted papers’ acceptance based on only the authors’ affiliations, only review, and both affiliation and review to be able to discern affiliation’s impact in comparable settings. Our first finding is SVM’s lower performance compared to the other two models and the benchmark we used. SVM could only reach an accuracy of 72.86% and an F-score of 82.57% with a single input of reviews. Surprisingly authors’ affiliation has certainly lower predictive power on article classification and had an accuracy of 65.71% and an F-score of 78.57%. When we based our predictions both on review and affiliation, we obtained almost the same results as the only affiliation - this time only with a hardly higher F-score.</p>
<h3 id="42-discussion-and-conclusion-a-classanchor-iddca">4.2. Discussion and Conclusion <!-- raw HTML omitted --><!-- raw HTML omitted --></h3>
<p>In this blog post, we studied the first public dataset of scientific peer reviews available for research purposes <a href="https://github.com/allenai/PeerRead">PeerRead</a> applying state-of-the-art NLP models ELMo and ULMFit to a text classification task [1]. We examined the importance of the peer reviews on paper’s acceptance or rejection decision in well-known conferences of computational linguistics, AI and NLP by using paper’s abstract, reviews and author’s affiliation. We detected that abstracts and authors&rsquo; affiliations do not have substantial predictive power. The results have shown that one could determine by nearly 80% accuracy whether a paper will be accepted or not by analyzing its reviews with deep learning methods. While the reviews appear to be successful at predicting - or leading to - paper’s classification based on our pre-labeled dataset, it is still a question if reviews are truly objective and consistent since the reviews themselves might create an inconsistency considering the NIPS Experiment (2014).</p>
<h2 id="5-reference-list-a-classanchor-idreferencesa">5. Reference List <!-- raw HTML omitted --><!-- raw HTML omitted --></h2>
<p>[1] Kang, D., Ammar, W., Dalvi, B., van Zuylen, M., Kohlmeier, S., Hovy, E., &amp; Schwartz, R. (2018). A dataset of peer reviews (peerread): Collection, insights and nlp applications. arXiv preprint arXiv:1804.09635.</p>
<p>[2] Google Scholar. (n.d.). In Wikipedia. Retrieved January 27, 2020, from <a href="https://en.wikipedia.org/wiki/Google_Scholar">https://en.wikipedia.org/wiki/Google_Scholar</a></p>
<p>[3] Scholarly 0.2.5. Retrieved Jan 27, 2020, from <a href="https://pypi.org/project/scholarly/">https://pypi.org/project/scholarly/</a></p>
<p>[4] Tang, J., Li, H., Cao, Y., &amp; Tang, Z. (2005, August). Email data cleaning. In Proceedings of the eleventh ACM SIGKDD international conference on Knowledge discovery in data mining (pp. 489-498).</p>
<p>[5] Sebastian Ruder, NLPs ImageNet moment has arrived, The Gradient, Jan. 27, 2020, <a href="https://thegradient.pub/nlp-imagenet/">https://thegradient.pub/nlp-imagenet/</a></p>
<p>[6] Pan, S. J., &amp; Yang, Q. (2009). A survey on transfer learning. IEEE Transactions on knowledge and data engineering, 22(10), 1345-1359.</p>
<p>[7] Jeremy Howard &amp; Sebastian Ruder , Introducing state of the art text classification with universal language models,  Retrieved Jan 29, 2020, from  <a href="https://nlp.fast.ai/classification/2018/05/15/introducing-ulmfit.html">https://nlp.fast.ai/classification/2018/05/15/introducing-ulmfit.html</a></p>
<p>[8] Howard, J., &amp; Ruder, S. (2018). Universal language model fine-tuning for text classification. arXiv preprint arXiv:1801.06146.</p>
<p>[9] Merity, S., Keskar, N. S., &amp; Socher, R. (2017). Regularizing and optimizing LSTM language models. arXiv preprint arXiv:1708.02182.</p>
<p>[10] Langford J. and Guzdial M. (2015) The arbitrariness of reviews, and advice for school administrators. Communications of the ACM Blog 58(4):12 13.</p>
<p>[11] Wan, L., Zeiler, M., Zhang, S., Le Cun, Y., &amp; Fergus, R. (2013, February). Regularization of neural networks using dropconnect. In International conference on machine learning (pp. 1058-1066).</p>
<p>[12] Smith, L. N. (2017, March). Cyclical learning rates for training neural networks. In 2017 IEEE Winter Conference on Applications of Computer Vision (WACV) (pp. 464-472). IEEE.</p>
<p>[13] Yosinski, J., Clune, J., Bengio, Y., &amp; Lipson, H. (2014). How transferable are features in deep neural networks?. In Advances in neural information processing systems (pp. 3320-3328).</p>
<p>[14] Cortes, C., &amp; Vapnik, V. (1995). Support-vector networks. Machine learning, 20(3), 273-297.</p>
<p>[15] Support-vector machine (n.d.). In Wikipedia. Retrieved January 31, 2020, from <a href="https://en.wikipedia.org/wiki/Support-vector_machine#Multiclass_SVM">https://en.wikipedia.org/wiki/Support-vector_machine#Multiclass_SVM</a></p>
<p>[16] Peters, M. E., Neumann, M., Iyyer, M., Gardner, M., Clark, C., Lee, K., &amp; Zettlemoyer, L. (2018). Deep contextualized word representations. arXiv preprint arXiv:1802.05365.</p>
<p>[17] What is peer review? Retrieved on Feb 01, 2020, from <a href="https://www.elsevier.com/reviewers/what-is-peer-review">https://www.elsevier.com/reviewers/what-is-peer-review</a></p>
<p>[18] AI HUB, Retrieved on Feb 05, 2020, from <a href="https://aihub.cloud.google.com/p/products%2Fd73ce2af-1179-4af9-bd2d-ffae7ea9f9ff">https://aihub.cloud.google.com/p/products%2Fd73ce2af-1179-4af9-bd2d-ffae7ea9f9ff</a></p>

                        </div>
                        
                        

                    </div>
                    

                    

                    

                    <div class="col-md-3">

                        

                        








<div class="panel panel-default sidebar-menu">
    <div class="panel-heading">
      <h3 class="panel-title">Categories</h3>
    </div>

    <div class="panel-body">
        <ul class="nav nav-pills nav-stacked">
            
            <li><a href="https://humboldt-wi.github.io/blog/categories/course-projects">course-projects (36)</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/categories/instruction">instruction (2)</a>
            </li>
            
        </ul>
    </div>
</div>











<div class="panel sidebar-menu">
    <div class="panel-heading">
      <h3 class="panel-title">Tags</h3>
    </div>

    <div class="panel-body">
        <ul class="tag-cloud">
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/a/b-testing"><i class="fa fa-tags"></i> a/b-testing</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/albert"><i class="fa fa-tags"></i> albert</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/attention"><i class="fa fa-tags"></i> attention</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/awd-lstm"><i class="fa fa-tags"></i> awd-lstm</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/bayesian-deep-learning"><i class="fa fa-tags"></i> bayesian-deep-learning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/bayesian-topic-modelling"><i class="fa fa-tags"></i> bayesian-topic-modelling</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/bert"><i class="fa fa-tags"></i> bert</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/bilm"><i class="fa fa-tags"></i> bilm</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/binary"><i class="fa fa-tags"></i> binary</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/black-box"><i class="fa fa-tags"></i> black-box</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/blockchain"><i class="fa fa-tags"></i> blockchain</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/causal-inference"><i class="fa fa-tags"></i> causal-inference</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/class17/18"><i class="fa fa-tags"></i> class17/18</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/class18/19"><i class="fa fa-tags"></i> class18/19</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/class19"><i class="fa fa-tags"></i> class19</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/class19/20"><i class="fa fa-tags"></i> class19/20</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/classification"><i class="fa fa-tags"></i> classification</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/coarsened-exact-matching"><i class="fa fa-tags"></i> coarsened-exact-matching</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/conversion"><i class="fa fa-tags"></i> conversion</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/convolutional-neural-networks"><i class="fa fa-tags"></i> convolutional-neural-networks</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/credit-risk"><i class="fa fa-tags"></i> credit-risk</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/data-simulation"><i class="fa fa-tags"></i> data-simulation</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/deep-learning"><i class="fa fa-tags"></i> deep-learning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/deeplearning"><i class="fa fa-tags"></i> deeplearning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/distant-transfer-learning"><i class="fa fa-tags"></i> distant-transfer-learning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/dml"><i class="fa fa-tags"></i> dml</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/doc2vec"><i class="fa fa-tags"></i> doc2vec</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/document-embeddings"><i class="fa fa-tags"></i> document-embeddings</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/economicuncertainty"><i class="fa fa-tags"></i> economicuncertainty</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/elmo"><i class="fa fa-tags"></i> elmo</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/embeddings"><i class="fa fa-tags"></i> embeddings</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/explanation"><i class="fa fa-tags"></i> explanation</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/fine-tuning"><i class="fa fa-tags"></i> fine-tuning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/genetic-matching"><i class="fa fa-tags"></i> genetic-matching</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/glove"><i class="fa fa-tags"></i> glove</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/gpt-2"><i class="fa fa-tags"></i> gpt-2</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/gru"><i class="fa fa-tags"></i> gru</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/hierarchical-network"><i class="fa fa-tags"></i> hierarchical-network</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/ice"><i class="fa fa-tags"></i> ice</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/image-analysis"><i class="fa fa-tags"></i> image-analysis</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/image-captioning"><i class="fa fa-tags"></i> image-captioning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/imbalanced-data"><i class="fa fa-tags"></i> imbalanced-data</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/inference"><i class="fa fa-tags"></i> inference</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/ite"><i class="fa fa-tags"></i> ite</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/keras-imdb-dataset"><i class="fa fa-tags"></i> keras-imdb-dataset</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/knn-algorithm"><i class="fa fa-tags"></i> knn-algorithm</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/language-model"><i class="fa fa-tags"></i> language-model</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/language-modeling"><i class="fa fa-tags"></i> language-modeling</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/language-modelling"><i class="fa fa-tags"></i> language-modelling</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/lda"><i class="fa fa-tags"></i> lda</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/lime"><i class="fa fa-tags"></i> lime</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/long-short-term-memory"><i class="fa fa-tags"></i> long-short-term-memory</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/lstm"><i class="fa fa-tags"></i> lstm</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/machine-learning"><i class="fa fa-tags"></i> machine-learning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/matching-methods"><i class="fa fa-tags"></i> matching-methods</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/matchit"><i class="fa fa-tags"></i> matchit</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/monte-carlo-dropout"><i class="fa fa-tags"></i> monte-carlo-dropout</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/movie-reviews"><i class="fa fa-tags"></i> movie-reviews</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/nearest-neighbor"><i class="fa fa-tags"></i> nearest-neighbor</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/neural-network"><i class="fa fa-tags"></i> neural-network</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/neural-networks"><i class="fa fa-tags"></i> neural-networks</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/nlp"><i class="fa fa-tags"></i> nlp</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/nn"><i class="fa fa-tags"></i> nn</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/optimal-matching"><i class="fa fa-tags"></i> optimal-matching</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/oversampling"><i class="fa fa-tags"></i> oversampling</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/pdp"><i class="fa fa-tags"></i> pdp</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/pretraining"><i class="fa fa-tags"></i> pretraining</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/propensity-score"><i class="fa fa-tags"></i> propensity-score</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/propensity-score-weighting"><i class="fa fa-tags"></i> propensity-score-weighting</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/recommendation"><i class="fa fa-tags"></i> recommendation</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/recommender-system"><i class="fa fa-tags"></i> recommender-system</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/recommender-systems"><i class="fa fa-tags"></i> recommender-systems</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/rnn"><i class="fa fa-tags"></i> rnn</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/roberta"><i class="fa fa-tags"></i> roberta</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/rs"><i class="fa fa-tags"></i> rs</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/sentiment-analysis"><i class="fa fa-tags"></i> sentiment-analysis</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/sentiment-classification"><i class="fa fa-tags"></i> sentiment-classification</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/seq2seq"><i class="fa fa-tags"></i> seq2seq</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/share-price-prediction"><i class="fa fa-tags"></i> share-price-prediction</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/simpletransformers"><i class="fa fa-tags"></i> simpletransformers</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/simulation"><i class="fa fa-tags"></i> simulation</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/survival-analysis"><i class="fa fa-tags"></i> survival-analysis</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/text-analysis"><i class="fa fa-tags"></i> text-analysis</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/text-classification"><i class="fa fa-tags"></i> text-classification</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/text-generation"><i class="fa fa-tags"></i> text-generation</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/text-mining"><i class="fa fa-tags"></i> text-mining</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/text-summarization"><i class="fa fa-tags"></i> text-summarization</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/time-series"><i class="fa fa-tags"></i> time-series</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/time-series-forecasting"><i class="fa fa-tags"></i> time-series-forecasting</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/toxic-comments"><i class="fa fa-tags"></i> toxic-comments</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/transfer-learning"><i class="fa fa-tags"></i> transfer-learning</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/transformers"><i class="fa fa-tags"></i> transformers</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/treatment-effect"><i class="fa fa-tags"></i> treatment-effect</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/twitter"><i class="fa fa-tags"></i> twitter</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/ulmfit"><i class="fa fa-tags"></i> ulmfit</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/uncertainty"><i class="fa fa-tags"></i> uncertainty</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/uplift"><i class="fa fa-tags"></i> uplift</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/uplift-modeling"><i class="fa fa-tags"></i> uplift-modeling</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/uplift-modelling"><i class="fa fa-tags"></i> uplift-modelling</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/variational-inference"><i class="fa fa-tags"></i> variational-inference</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/wikitext-103"><i class="fa fa-tags"></i> wikitext-103</a>
            </li>
            
            <li><a href="https://humboldt-wi.github.io/blog/tags/word-embeddings"><i class="fa fa-tags"></i> word-embeddings</a>
            </li>
            
        </ul>
    </div>
</div>



















                        

                    </div>
                    

                    

                </div>
                

            </div>
            
        </div>
        

        <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<footer id="footer">
    <div class="container">

        

        <div class="col-md-4 col-sm-6">

             
            

            
                
                
                    
                        
                          
                            
                          
                        
                    
                    
                        
                    
                
                
                
                    
                        
                          
                            
                          
                        
                    
                    
                        
                    
                
                
                
                    
                        
                          
                            
                          
                        
                    
                    
                        
                    
                
                
            

            <hr class="hidden-md hidden-lg">
             

        </div>
        

        

    </div>
    
</footer>







<div id="copyright">
    <div class="container">
        <div class="col-md-12">
            
            <p class="pull-left">Copyright (c) 2017, Chair of Information System at HU-Berlin; all rights reserved.</p>
            
            <p class="pull-right">
              Template by <a href="http://bootstrapious.com/free-templates">Bootstrapious</a>.
              

              Ported to Hugo by <a href="https://github.com/devcows/hugo-universal-theme">DevCows</a>
            </p>
        </div>
    </div>
</div>





    </div>
    

    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-112025566-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

<script src="//code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-cookie/1.4.1/jquery.cookie.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/waypoints/4.0.1/jquery.waypoints.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/Counter-Up/1.0/jquery.counterup.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery-parallax/1.1.3/jquery-parallax.js"></script>

<script src="//maps.googleapis.com/maps/api/js?v=3.exp"></script>

<script src="https://humboldt-wi.github.io/blog/js/hpneo.gmaps.js"></script>
<script src="https://humboldt-wi.github.io/blog/js/gmaps.init.js"></script>
<script src="https://humboldt-wi.github.io/blog/js/front.js"></script>


<script src="https://humboldt-wi.github.io/blog/js/owl.carousel.min.js"></script>


  </body>
</html>
